#!/usr/bin/with-contenv bash

log () {
    echo "$(date +'%F %T') ${*}" | tee -a /config/logs/backup.log
}

fail () {
    log "${*}"
    exit 1
}

backup_fail () {
    test -n "${backup_filename}" && rm -f "${backup_filename}"
    test -n "${tmpfile}" && rm -f "${tmpfile}"
    log "${*}"
    exit 1
}

# If we stay in /root we'll get warnings when find finishes
cd "/config/mmonit-${MMONIT_VERSION}" || fail "Unable to cd into /config/mmonit-${MMONIT_VERSION}"

test -d /backup || fail "/backup is not a directory"
test -w /backup || fail "/backup is not writable directory"

# Determine backup type from filename
case ${0} in
    */monthly/*)
	type=monthly
	age=$(expr 52 '*' 7)
	;;
    */weekly/*)
	type=weekly
	age=$(expr 4 '*' 7)
	;;
    */daily/*)
	type=daily
	age=7
	;;
    */hourly/*)
	type=hourly
	age=0
	;;
    *)
	fail "Unable to determine backup time from filename: ${0}"
	;;
esac

# Parse the database URL
if [[ "${MMONIT_DATABASE_URL}" =~ ^[a-z]+://.+ ]]; then
    database="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{scheme}')"
    database_user="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{user}')"
    database_password="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{password}')"
    database_host="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{host}')"
    database_port="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{port}')"
    database_name="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{path}' | cut -d '/' -f 2)"
    suffix=sql
    case "${database}" in
    "mysql")
	    backup_prog=mariadb-dump
	    database_pkg=mariadb-client
	    ;;
    *)
	    fail "Unsupported database type: ${database}"
	    ;;
    esac
else
    database=sqlite3
    suffix=sq3
    backup_prog=sqlite3
    database_pkg=sqlite
fi

# Install the package we need
which "${backup_prog}" >/dev/null || {
    output=$(apk add -Uq "${database_pkg}" 2>&1)
    test $? -ne 0 && fail "Unable to install ${database_pkg}: ${output}"
}

# Create backup filename and check that it exists
backup_filename="/backup/mmonit_backup_$(date +'%FT%T')_${type}.${suffix}"
test -e "${backup_filename}" && fail "${backup_filename} exists"
tmpfile=$(mktemp -t "${progname}.XXXXXXXXXX")
cnffile=$(mktemp -t database.cnf.XXXXXXXXXX)
trap "rm -f ${backup_filename} ${tmpfile} ${cnffile}" 1 2 3 13 15

# Process backup per DB method
case "${database}" in
    "mysql")
    database_socket="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{query:unix-socket}')"
    cat > "$cnffile" <<EndOfDocument
    [client]
    host = ${database_host}
    port = ${database_port:-3306}
    user = ${database_user}
    password = ${database_password}
    socket = ${database_socket}
EndOfDocument
	for try in $(seq 1 10); do
	    output=$(s6-setuidgid abc ${backup_prog} --defaults-file "${cnffile}" -r "${backup_filename}" "${database_name}" 2>&1)
	    test $? -eq 0 && break
	    log "Backup failed (attempt ${try}): ${output}"
	    sleep ${try}
	done
	;;
    "postgresql://")
	fail "Backing up PostgresQL is not yet supported"
	;;
    ""|"sqlite://")  # Assume sqlist
	for try in $(seq 1 10); do
	    output=$(s6-setuidgid abc ${backup_prog} db/mmonit.db ".backup ${backup_filename}" 2>&1)
	    test $? -eq 0 && break
	    log "Backup failed (attempt ${try}): ${output}"
	    sleep ${try}
	done
	;;
esac

# Verify backups
test -s "${backup_filename}" || backup_fail "ERROR: ${backup_filename} not created or empty"
case "${database}" in
    "mysql")
	n_lines=$(wc -l "${backup_filename}")
	n_lines="${n_lines%% *}"
	test ${n_lines} -gt 3 || backup_fail "Backup verification failed: only ${n_lines} lines!"
	;;
    "postgresql")
	fail "Backing up PostgresQL is not yet supported"
	;;
    "sqlite")  # Assume sqlist
	s6-setuidgid abc ${backup_prog} "${backup_filename}" .dump > "${tmpfile}"
	test $? -ne 0 && backup_fail "Backup verification failed"
	n_lines=$(wc -l "${tmpfile}")
	n_lines="${n_lines%% *}"
	rm -f "${tmpfile}"
	test ${n_lines} -gt 3 || backup_fail "Backup verification failed: only ${n_lines} lines!"
	;;
esac
log "${backup_filename} created and verified"

# Clean up old backups
output=$(s6-setuidgid abc find /backup -name \*_${type}.* -mtime +${age} -delete -print 2>&1)
test $? -ne 0 && fail "Cleaning old backups older than ${age}: ${output}"
test -n "${output}" && log "Cleaned older than ${age}: ${output%%$'\n'*}"

exit 0
