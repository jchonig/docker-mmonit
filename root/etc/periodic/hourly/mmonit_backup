#!/usr/bin/with-contenv sh

progname=$(basename "${0}")

log () {
    echo "$(date +'%F %T') ${*}" | tee -a /config/logs/backup.log
}

fail () {
    log "${*}"
    exit 1
}

backup_fail () {
    test -n "${backup_filename}" && rm -f "${backup_filename}"
    test -n "${tmpfile}" && rm -f "${tmpfile}"
    log "${*}"
    exit 1
}

# If we stay in /root we'll get warnings when find finishes
cd "/config/mmonit-${MMONIT_VERSION}" || fail "Unable to cd into /config/mmonit-${MMONIT_VERSION}"

test -d /backup || fail "/backup is not a directory"
test -w /backup || fail "/backup is not writable directory"

# Determine backup type from filename
case ${0} in
    */monthly/*)
	type=monthly
	age=$(expr 52 '*' 7)
	;;
    */weekly/*)
	type=weekly
	age=$(expr 4 '*' 7)
	;;
    */daily/*)
	type=daily
	age=7
	;;
    */hourly/*)
	type=hourly
	age=0
	;;
    *)
	fail "Unable to determine backup time from filename: ${0}"
	;;
esac

# Parse the database URL
database=$(expr "${MMONIT_DATABASE_URL}" : '\(.*\)://.*$')
if [ -n "${database}" ]; then
    suffix=sql
    case "${database}" in
	"mysql")
	    test -f /etc/mysqldump.cnf || fail "/etc/mysqldump.cnf not found"
	    ;;
	*)
	    fail "Unsupported database type: ${database}"
	    ;;
    esac
else
    database=sqlite3
    suffix=sq3
fi

# Create backup filename and check that it exists
backup_filename="/backup/mmonit_backup_$(date +'%FT%T')_${type}.${suffix}"
test -e "${backup_filename}" && fail "${backup_filename} exists"
tmpfile=$(mktemp -t ${progname}.XXXXXXXXXX)
trap "rm -f ${backup_filename} ${tmpfile}" 1 2 3 13 15

# Process backup per DB method
case "${database}" in
    "mysql")
	database_name="$(trurl --url "${MMONIT_DATABASE_URL}" --get '{path}' | cut -d '/' -f 2)"
	for try in $(seq 1 10); do
	    output=$(s6-setuidgid abc mariadb-dump --defaults-file=/etc/mysqldump.cnf -r "${backup_filename}" "${database_name}" 2>&1)
	    test $? -eq 0 && break
	    log "Backup failed (attempt ${try}): ${output}"
	    sleep ${try}
	done
	;;
    "postgresql://")
	fail "Backing up PostgresQL is not yet supported"
	;;
    ""|"sqlite://")  # Assume sqlist
	for try in $(seq 1 10); do
	    output=$(s6-setuidgid abc sqlite3 db/mmonit.db ".backup ${backup_filename}" 2>&1)
	    test $? -eq 0 && break
	    log "Backup failed (attempt ${try}): ${output}"
	    sleep ${try}
	done
	;;
esac

# Verify backups
test -s "${backup_filename}" || backup_fail "ERROR: ${backup_filename} not created or empty"
case "${database}" in
    "mysql")
	n_lines=$(wc -l ${backup_filename})
	n_lines="${n_lines%% *}"
	test ${n_lines} -gt 3 || backup_fail "Backup verification failed: only ${n_lines} lines!"
	;;
    "postgresql")
	fail "Backing up PostgresQL is not yet supported"
	;;
    "sqlite")  # Assume sqlist
	s6-setuidgid abc sqlite3 "${backup_filename}" .dump > "${tmpfile}"
	test $? -ne 0 && backup_fail "Backup verification failed"
	n_lines=$(wc -l "${tmpfile}")
	n_lines="${n_lines%% *}"
	rm -f "${tmpfile}"
	test ${n_lines} -gt 3 || backup_fail "Backup verification failed: only ${n_lines} lines!"
	;;
esac
log "${backup_filename} created and verified"

# Clean up old backups
output=$(s6-setuidgid abc find /backup -name \*_${type}.* -mtime +${age} -delete -print 2>&1)
test $? -ne 0 && fail "Cleaning old backups older than ${age}: ${output}"
test -n "${output}" && log "Cleaned older than ${age}: ${output%%$'\n'*}"

exit 0
